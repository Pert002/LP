# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Иванопуло А.Б.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В Прологе, как и во многих других языках программирования, можно хранить не только отдельные элементы, но и какие-то наборы различных элементов. Для этого используется такая структура данных, как список. Списки в Прологе отличаются от списков, например, в языке Python, к которым все так привыкли. Здесь список - это либо пустой элемент, либо один элемент, называемый головой, и присоединенный список - хвост. Это рекурсивная структура данных с последовательным доступом. Прологовский список это скорее некий гибрид очереди и линейного списка. В рамках данной лабораторной работы мне предложено более подробно разобраться с этой структурой данных в Прологе и научиться работать с ней.

## Задание 1.1: Предикат обработки списка

### Стандартные предикаты работы со списками:
```prolog
% Предикат получения длины списка.
my_length([], 0). 
my_lenght([_|Tail], N) :- my_lenght(Tail, N1), 
                        N is N1 + 1.

% Предикат проверки принадлежности элемента X списку List.
my_member(Head, [Head|_]).
my_member(X, [_|Tail]) :- my_member(X, Tail).

% Объединение списков List1 и List2. Результат List3.
my_append([], List2, List2).
my_append([Head | Tail1], List2, [Head | Tail3]) :- my_append(Tail1, List2, Tail3).

% Предикат удаления элемента X из списка List.
my_remove(X,[X|T],T).
my_remove(X,[H|T],[H|Y]) :- my_remove(X,T,Y).

% Предикат проверки перестановки списка
my_permute([],[]).
my_permute(X,[H|T1]) :-
  my_remove(H,X,T),
  my_permute(T,T1).

% Предикат проверки подсписка
my_sublist(Sub, List) :-
	my_append(_, L2, List),
	my_append(Sub, _, L2).
```

`count_entry(X,[H|T],N)` - подсчет числа вхождений N заданного элемента X в список List (без стандартных предикатов)
`std_count_entry` - подсчет числа вхождений N заданного элемента X в список List

Реализация:
```prolog
count_entry(_,[],0).
count_entry(X,[X | Tail], N) :-
	count_entry(X, Tail , N1),
	N is N1 + 1, !.
count_entry(X, [_ | Tail], N) :-
	count_entry(X, Tail, N).
```

Условия рекурсии:

1. При любом элементе, если список пусто, то число вхождений равно 0.
2. Если элемент совпадает с головой списка, то запускаем рекурсивно count_entry только уже с хвостом списка, полученный результат рекурсии будет содержаться в N1, а изначальное число вхождений будет находиться как сумма N1 + 1, т.к. голова списка уже совпала с элементом.
3. Иначе если элемент не совпал с головой списка, то запускаем рекурсию с хвостом списка, не увеличивая число вхождений.

Реализация:
```prolog
std_count_entry(_, [], 0).
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A = X,
	std_count_entry(X, NEW, N1),
	N is N1 + 1, !.
std_count_entry(X, List, N) :-
	my_remove(A, List, NEW),
	A \= X,
	std_count_entry(X, NEW, N).
```
С помощью стандартного метода перебора и удаления элемента из списка мы рассматриваем каждый элемент и проверяем на совпадение с нужным элементом, если совпало, то запускаем рекурсию и увеличиваем результата на 1, иначе просто запускаем рекурсию.

## Задание 1.2: Предикат обработки числового списка

`max(X,[H|T]) - вычисление максимального элемента (без стандартных предикатов)`
`std_max(X,[H|T]) - вычисление максимального элемента`

Реализация:
```prolog
max(X,[X | Tail]) :-
	maxhelp(X, Tail), !.
max(MAX, [_ | Tail]) :-
	max(MAX, Tail). 
```

Рекурсивно сравниваем потенциальный максимальный элемент с головой списка. Если данный элемент не подошел, то запускаем рекурсию для следующего элемента.

Реализация:
```prolog
std_max(X, [X | Tail]) :- 
	maxhelp(X, Tail), !.
std_max(MAX, [X | Tail]) :-
	my_remove(X, [X | Tail], List),
	std_max(MAX, List).
```

Принцип такой же, как и в реализации вычисления максимального элемента без использования стандартных предикатов, только элемент, который не подошел, удаляется с помощью `remove`.

## Задание 2: Реляционное представление данных

Реляционное представление данных порой оказывается очень удобным для использования. Достоинствами реляционного представления является простота организации базы данных, наличие строгих правил проектирования и полная независимость данных. Однако в качестве недостатков можно выделить относительно большой объём занимаемой памяти.

В моем варианте использовалось представление данных в виде фактов следующей структуры:

```grade(группа, фамилия, предмет, оценка).```
## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе. Чему она вас научила? Над чем заставила задуматься? Помните, что несодержательные выводы -
самая частая причина снижения оценки за лабораторную.




